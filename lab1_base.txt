lab 1

1. 操作系统是一个软件,也需要通过某种机制加载并运行它.这里需要通过另外一个更加简单的软件
   bootloader 来完成这些工作.

2. 我们需要完成一个能够切换到 x86 的保护模式 (protect mode) 并显示字符的 bootloader, 
   为启动 kernel 做准备.

3. proj1 实践了一个非常小的 bootloader 和 kernel, 整个 bootloader 执行代码小于 512 byte.
   这样才能放到硬盘的主引导扇区中.


Content

1、 计算机原理: CPU 的编址与寻址:基于分段(segment)机制的内存管理; CPU 的中断机制 (trap); 
    外设: 串口/并口/CGA、时钟,硬盘.

2、 Bootloader 软件:
		编译运行 bootloader 的过程;  
		Debug bootloader 的方法;
		PC 启动 bootloader 的过程;
		ELF 执行文件的格式和加载;
		外设访问: 读硬盘, 在CGA上显示字符串;

	 Kernel 软件
		编译运行 kernel 的过程;
		kernel 的启动过程;
		Debug kernel 的方法;
		C 函数调用关系: 从汇编级别理解函数调用栈的结构与处理过程;
		中断管理: 与软件相关的中断处理(Soft Interrupt) ;
		外设管理: 时钟



#1 从机器启动到操作系统运行的过程 BIOS 启动过程

        1. 当计算机加电后,一般不直接执行操作系统,而是执行系统初始化软件完成基本IO初始化和引导加载功能.
           简单地说,系统初始化软件就是在操作系统内核运行之前运行的一段小软件.通过这段小软件,我们可以初
           始化硬件设备、建立系统的内存空间映射图,从而将系统的软硬件环境带到一个合适的状态,以方便为最
           终调用 OS kernel 准备好正确的 环境.最终引导加载程序把 OS kernel 映像加载到 RAM 中,并将系统控制权传递给它.

        2. 对于大多数计算机系统而言,os 和 application 软件是存放在磁盘(硬盘)、ROM等可在断电后继续
           保存数据的存储介质上.计算机启动后, CPU 一开始会到一个特定的地址开始执行指令,这个特定的地 
           址存放了系统初始化软件,负责完成计算机基本的 IO 初始化,这是系统加电后运行的第一段软件代码.
           对于 Inter 80386 的体系结构而言, PC 机的系统初始化软件由 BIOS (Basic Input Output 
           System, 即基本输入/输出系统,其本质是一个固化在主板 Flash/CMOS 上的软件)和位于硬盘引导扇
           区中的 OS Boot Loader (bootasm.S 和bootmain.c)一 起组成. BIOS实际上是被固
           化在计算机 ROM (只读存储器)芯片上的一个特殊的软件,为上层软件提供最底层的、最直接的硬件控制
           与支持.更形象的说, BIOS 就是PC计算机硬件与上层软件程序之间的 一个“桥梁”,负责访问和控制硬件.

        3. 以 Intel 80836 体系结构为例,计算机加电后, CPU 从 物理地址 0xffffFFF0(由初始化的 
           CS:EIP 确定,此时 CS 和 EIP 的值分别是 0XF000 和 0xFFF0) 开始执行.在 0xffffFFF0 这里
           只是存放了一条跳转指令,通过跳转指令跳转到 BIOS 例行程序起始点. BIOS 做完计算机硬件自检和初
           始化后,会选择一个启动设备(硬盘),并且读取该设备的第一扇区(主引导扇区或启动扇区) 到内存一个特
           定的地址 0x7c00 处,然后 CPU 控制权会转移到那个地址继续执行. 至此BIOS的初始化工作做完了,进
           一步的工作交给了 os 的 bootloader.


#2 bootloader启动过程: BIOS 将通过读取硬盘主引导扇区到内存,并转跳到对应内存中的位置执行 bootloader.
                    bootloader 完成的工作包括:
    1. 把CPU从实模式切换到保护模式,启动分段机制;
    2. 读取硬盘中 ELF 执行文件格式的 os 操作系统到内存;
    3. 显示字符串信息 (init_console);
    4. 把控制权交给 os kernel;
    5. 对应其工作的实现文件在 boot 目录下的三个文件 asm.h、bootasm.S和bootmain.c.
    6. 下面从 OS 原理上介绍完成上述工作的计算机系统硬件和软件背景知识.
                          
        保护模式和分段机制
        
        1. 为什么要了解Intel 80386的保护模式和分段机制?首先,我们知道Intel 80836只有
           在进入保护模式后,才能充分发挥其强大的功能,提供更好的保护机制和更大的
           址空间,否则仅仅是一个快速的8086而已.没有一定的保护机制,任何一个 application
           软件都可以任意访问所有的计算机资源,这样也就无从谈起操作系统设计了.
    
        2. 并且 Intel 80836 的分段机制一直存在,无法屏蔽或者避免.
         
        3. 其次,在我们的 bootloader 设计中,涉及到了从实模式切到保护模式的处理,
           我们的操作系统功能(比如分页机制)是建立在Intel 80836的保护模式上来设计的.
        
        4. 如果不了解保护模式和分段机制,则面向 Intel 80386 体系结构的操作系统设计实际
           上是建立在一个空中楼阁之上的.
        
        5. waring: 虽然学习过 x86 汇编,对 x86 硬件 架构有一定了解,但对x86保护模式和x86
           系统编程可能了解不够.可以参考资料 (Intel 手册)第4,6,9,10章.
                        
        
        实模式:
            1. 在 bootloader 接手 BIOS 的工作后,当前的 PC 系统处于实模式(16bit模式, 由于使用了 20 根地址线,所以可以寻址 1MB ,但是由于 CPU 内部的寄存器只有 16 bit(以前的旧 cpu),因此为了能访问整个 1MB内存,所以采用了 段地址+偏移地址来寻址 => 段地址 * 16 + offset) 运行状态, 在这种状态下软件可访问的物理内存空间的上限为1MB (2^20),且无法发
            挥Intel 80386以上级别的 32bit CPU 的 4GB(2^32) 内存管理能力.     
                            
            2. 实模式将整个物理内存看成分段的区域, 程序代码和数据位于不同区域,操作系统
               和用户程序并没有区别对待,而且每一个指针都是指向实际的物理地址.这样,用
               户程序的一个指针如果指向了操作系统区域或其他用户程序区域,并修改了内容,
               那么其后果就很可能是灾难性的.通过修改 A20 地址线可以完成从实模式到保护模式的转换.

            3. 主要特点 A:内部寄存器为 16bit ; B:最大寻址空间为 1MB ; C:可以访问内存中的任意位置
               
    保护模式        
        1. 只有在保护模式下,80386的全部 32根地址线有效,可以寻址高达 4GB 的线性地址空间和物理地址空间,
           可以访问 64TB(有 2^14 个段,每个段最大空间为 2^32字节)的逻辑地址空间,可采用分段存储管理机
           制和分页存储管理机制.
                                                          
        2. 这不仅为存储共享和保护提供了硬件支持,而且为实现虚拟存储提供了硬件支持.
                             
        3. 通过提供4个特权级和完善的特权检查机制,既能实现资源共享又能保证代码数据的安全以及任务的隔离.
                            
        4. waring:保护模式下,有两个段表:  GDT (Global Descriptor Table ) 和  LDT (Local  
           Descriptor Table),每一张段表可以包含 8192 (2^13) 个描述符,因而最多可
           以同时存在 2 * 2^13 = 2 ^14个段. 虽然保护模式下可以有这么多段,逻辑地址空间看起来很大,但实际上
           段并不能扩展物理地址空间,很大程度上各个段的地址空间是相互重叠的.目前所谓的 64TB (2^(14+32) = 2^46) 逻辑地址空间是一个理论值,没有实际意义.
           在32bit保护模式下,真正的物理空间仍然只有2^32字节那么大.kernel 中只用了GDT,并没有用LDT. (《Intel64 and IA-32 Architecture Software Developer’s Manual》).

         5. 主要特点  A:内部寄存器 32bit;  B:最大寻址空间 4GB;   C: 段寄存器中保存段的选择子(不再
           是段基地址)
        

  实模式与保护模式的比较:
  
  1. 内存访问模式 => 本质上还是采用了 段地址 + offset 的寻址模式;
     A : 实模式 ===> 段寄存器 (cs , ss , es, ds , fs...)中存储的就是段基址,可以没有限制的 read |    write ; 换句话说就是=>可以直接用里面存储的内容.
         
         1: ==> 使用 lldt 直接接在内存
    
     B: 保护模式 ====>  段寄存器 (cs , ss , es, ds , fs...) 中不再存储段基址, 而是段的选择子,而且
        段寄存器还包括一个不可见的部分,描述符高速缓冲器.

        1: ==> 访问模块 与 实模式不同, 每当引用一个段,可以理解为改变段地址内容的指令 jmp / call | 
                mov ax, ...   , mov ds, ax ;调用该类指令时,会将段地址左移 4 bit, 并传送到描述符
                高速缓冲器,并且之后如果没有改变段地址(调用上面一类的指令),访问该段寄存器时,便一直使用该地址.
        2: ==> 要访问内存时,传送给段寄存器的内容不再是逻辑段地址(就是实模式中的直接可用的地址),而是段
               描述符在描述符表中的索引号

    https://blog.csdn.net/liutianshx2012/article/details/52369163
  2. 段描述符表 (是段描述符的一个数组)
     A: 实模式 ===> 在进入保护模式之前,描述表就是描述符的集合, 描述符存储的是段相关信息,描述符统一的(连
        续的)一个挨着一个的放在内存中,这就是构成一个描述符表. 

        1: ==>  GDT  全局描述符表, 是为整个软硬件系统服务的,必须在进入保护模式之前定义.

                系统中每个 CPU 有属于自己的一个全局描述符表(GDT),其所在内存的基地址和
                其大小一起保存在 CPU的 GDTR 寄存器中,其大小为64K,一共可保存 8192 个段描述符.

                不过第一个一般都会置空,也就是能保存8191个段描述符.

                第一个置空的原因是防止加电后段寄存器未经初始化就进入保护模式而使用 GDT.

        2: ==>  LDT  局部描述符表, 是每个用户程序拥有一个 LDT 且自能自身使用, 每个 LDT 都在 GDT 中
                有一个映射描述符(Segment Descriptor).

                (个人理解) ==> GDT 和 LDT 分别为一级描述符表与二级描述符表. 两者本质上相同,只是 
                LDT 嵌套在 GDT 之中. 

                当前被使用的 LDT 的基地址和大小一起保存在 LDTR 寄存器中.
                不过大多数用户态的 liunx 程序都不使用局部描述符表,所以linux内核只定义了一个缺省的
                LDT 供大多数进程共享. 描述这个 LDT 的描述符保存在 GDT 中.


        3: ===> 全局描述符表寄存器 GDTR , 该寄存器 48 bit, 高 32 bit 代表 基地址 + 低16 bit代表
                描述符表的大小 (2 ^16 = 64kb).
                由于 一个描述符占 8 byte ( 64 bit = 2 ^6)因此最多可以定 义 8192 (2 ^ 13) 个描述符.


   3. 段描述符 ==> GDT | LDT 表中的一个数据结构项.
                
                用于向 CPU 提供有关一个段的位置和大小信息以及访问控制的状态信息.
                
                每个段描述符长度是 64 bit  ,含有三个主要字段: 段基地址,段限长和段属性. 
                
                段描述符通常由编译器,链接器,加载器或者操作系统来创建,但绝不是应用程序.

                A : ===> LIMIT (Segment limit field) 段限长字段. 

                B : ===> BASE (Base address field) 基地址字段. 定义了在 4GB 线性空间中一个段
                         字节 0 所处的位置. 一般程序将 Data segment & Code segment 16 bit 对齐,可以具有最佳性能.
                C : ===> TYPE 
                         类型字段指定 段(segment) 或者 门(gate) 的类型,说明段的访问种类
                         以及段的扩展方向.  

                         该字段的解释依赖于描述符类型标志 S 指明一个段描述符是系统段描述符(S=0)
                         还是代码段或数据段描述符 (S=1)

                         TYPE 字段的编码 ==> Code segment | Data Segment |system Segment
                         描述符都不同.

                         S=0,表示为 系统描述符, CPU 能识别以下几种 type segment descriptor

                         1 ==> LDT 中的 segment descriptor
                         2 ==> TSS  segment descriptor
                         3 ==> 调用门 segment descriptor
                         4 ==> 中断门 segment descriptor
                         5 ==> 陷阱门 segment descriptor
                         6 ==> 任务门 segment descriptor

                        这 6 种描述符类型可分为两大类 
                            系统段描述符  &  门描述符
                            系统段描述符指向系统段（如LDT 和TSS段）.
                            门描述符就是一个“门”,对于调用、中断、陷阱门,其中含有代码段的段选择子和处理函数的入口地址(为相应的idt数组内容);
                            对于任务门,其中含有 TSS 的段选择符.

                        

                D : ===> S (Descriptor type field) 1 bit ,S=0 System ;S=1 Code | Data
                        
                         S =1 时,最高 bit (第 2 个 DWORD 的位 11)用于确定 Data (复位)
                                还是 Code (置位).

                E : ===> DPL (Descriptor Privilege Level)  0~3 ring level   2 bit. 
                         指明描述符的特权级,控制对段的访问权限.

                         当DPL=0时,只有 CPL=0 才能访问;
                         DPL=3时,CPL=0~3 都可以访问这个段.


                F : ===> P (Segment Present) P=1 在内存中;P=0 不在内存中,缺页异常 1 bit.
                         当一个 段描述符 的 P = 0 时,那么把指向这个段描述符的选择子加载进 段寄存器
                         (CS/SS/DS/ES/FS/GS)将会产生一个段不存在的异常. 这个功能为 虚拟内存存储
                         提供了除分页机制以外的控制.

                G : ====> D/B (Default operation size | Stack pointer size | upper bound)

                         根据段描述符的属性,描述的是一个可执行的代码段 、 下扩数据段、堆栈段的不同,
                         这个标志具有不同的功能. 

                         对于 32 bit 代码 和 数据段,这个标志应该总是设置为 1;
                         对于 16 bit 代码 和 数据段,这个标志应该总是设置为 0.
                
                H : ====> G(Granularity)颗粒度标志
                        该字段用于确定段限长字段 Limit 值得单位.
                        假设 G=0,则 Limit 的单位为 byte; G =1 ,Limit 单位为 4kb.
                        不影响段基地址的颗粒度,基地址的颗粒度总是 byte.
                        当 设置了 G ,那么使用 Limit 来检查 offset 时,并不会去检查 offset 的 12 bit 最低有效位.   G =1, Limit  = 0 ,表明有效 offset 为 0~4095.
                I : ====> Available bits 保留比特位
                        段描述符第 2 个 DWORD 的 位 20 可供系统软件使用; 位 21 是保留位并应该总是0.


        TLS 段描述符 ==> 局部线程存储段,这个会允许线程拥有自己的段. 
                        不过一般程序不经常使用. System call : set_thread_area() | get_thread_area() 为当前 process 的创建和撤销一个 TLS 段.

        TSS 段描述符 ==> 任务状态段,非常重要.

                        主要保存当前进程的 IO 许可权限位 和 stack pointer;

                        主要有两个作用:

                        1==> 进程从用户态切换到内核态时,系统会从该 CPU 的 TSS 中获取该进程的内核态堆栈地址.
                        2==> 当用户态进程试图通过 in 或 out 指令访问一个 IO 端口时,CPU 需要访问存放在 TSS 中的 IO 许可权限位以检查该进程是否有权限访问该 IO 端口.

                        每个 CPU 包含一个自己的 TSS 段, 主要是一个 tss_struct
                        结构体, linux 会将所有 CPU 的tss_struct 以 init_tss 数组的形式保存起来,这个 tss_struct 结构体中保存的时当前运行进程的内核态堆栈栈顶地址和当前进程的 IO 许可权限位. 
                        当进程切换时就会设置CPU的tss_struct结构体,CPU 就可以从 tss_struct 中获
                        取当前进程的内核栈和IO许可权限.

        代码段描述符  ==> 这个段描述符代表一个代码段,这种描述符可以放在 GDT 或者 LDT. S=1
                        KERNEL_CS 属于 代码段描述符 而不属于 系统段描述符.

        数据段描述符  ==> 这个段描述符代表一个数据段,这种描述符可以放在 GDT 或者 LDT. S=1
                        该类型描述符,类型字段的低 3 bit (位 8、9、10)被分别用于表示已访问 A(Accessed), 可写 W (Write-enable) 和 扩展方向 E (Expansion-direction)

                        E ==> 向下扩展
                        A ==> 可访问
                        W ==> 可写(读)
                        C (Conforming) ==> 一致性段
                        X ==> 可执行

                        --------------------------------------------------------
                            TYPE   |   E    |   W   |   A   |
                        --------------------------------------------------------
                            bit 11 | bit 10 | bit 9 | bit 8 | type | descriptor|
                        --------------------------------------------------------
                               0   |   0    |    0  |   0   | data | only R 
                        --------------------------------------------------------
                               0   |   0    |    0  |   1   | data | only R | A
                        --------------------------------------------------------
                               0   |   0    |    1  |   0   | data | R | W
                        --------------------------------------------------------
                               0   |   0    |    1  |   1   | data | R|W | A
                        --------------------------------------------------------
                               0   |   1    |    0  |   0   | data | E | R
                        --------------------------------------------------------
                               0   |   1    |    0  |   1   | data | E|R|A
                        -------------------------------------------------------- 
                               0   |   1    |    1  |   0   | data | E|R|W
                        --------------------------------------------------------
                               0   |   1    |    1  |   1   | data | E|R|W|A
                        --------------------------------------------------------
                                   |   C    |    R  |   A   |      | 
                        --------------------------------------------------------
                               1   |   0    |    0  |   0   | code | only X
                        --------------------------------------------------------
                               1   |   0    |    0  |   1   | code | X|A
                        --------------------------------------------------------
                               1   |   0    |    1  |   0   | code | R|X
                        -------------------------------------------------------- 
                               1   |   0    |    1  |   1   | code | R|X|A
                        --------------------------------------------------------
                               1   |   1    |    0  |   0   | code | C|only X
                        --------------------------------------------------------
                               1   |   1    |    0  |   1   | code | C|X|A
                        --------------------------------------------------------
                               1   |   1    |    1  |   0   | code | C|X|R
                        --------------------------------------------------------
                               1   |   1    |    1  |   1   | code | C|X|R|A
                        --------------------------------------------------------
                                                  
                        一个数据段一定是可读的, 也有可能有写的权限.
                        在保护模式下,代码段是不可写的.
                        
                        堆栈段必须是 R|W 的数据段. 否则使用 不可W 的数据段的 segment seltor 加载
                        到 SS 中,将导致一个一般保护异常.    如果堆栈段的长度需要动态地改变,那么堆栈
                        段可以是一个 E 的数据段.这里改变 segment Limit 将导致栈空间被添加到栈底.

                        已经访问bit 指明自从上次 OS 复位该 bit 之后,一个段是否被访问过. 每当CPU 把
                        一个 daunting segment seltor 加载进 段寄存器,它就会设置该 bit. 该bit 
                        必须明确地清除,否则一直保持置位状态. 该bit 可用于 虚拟内存管理和调试.

                        
                        对于代码段,类型字段的低 3 位被解释成已访问A(Accessed),可读R
                        (Read-enable) 和一致的C(Conforming).根据可读R标志的设置,代码段可以是
                        只能执行,可执行/可读.当常数或其他静态数据以及指令码被放在一个ROM 中时就可以
                        使用一个可执行、可读代码段.这里,通过使用带 CS 前缀的指令或者把代码段选择符加载进一个数据段寄存器(DS,ES,FS,GS),我们可以读取代码段中的数据. 


                        
                        代码段可以是一致性的或非一致性的.向更高特权级一致性代码段的执行控制转移,允许
                        程序以当前特权级继续执行.想一个不同特权级的非一致性代码段的转移将导致一般保护
                        异常,除非使用了一个调用门或任务门(有关一致性和非一致性代码段的详细信息请参考
                        其他资料).不访问保护设施的系统工具以及某些异常类型(例如出错,溢出)的处理过
                        程可以存放在一致性代码段中.需要防止低特权级程序或过程访问的工具应该存放在非一
                        致性代码段中.

                        所有数据段都是非一致性的,即意味着它们不能被低特权级的程序或过程访问.
                        然而,与代码段不同,数据段可以被更高特权级的程序或过程访问,而无须使用特殊的访问门.

                        如果 GDT | LDT 中一个 segment descriptor 被存放在 ROM 中,那么若软件或
                        CPU 试图更新(W) 在 ROM 中的 段描述符时,CPU 就会进入一个无限循环.同时,删除
                        操作系统中任何试图修改 ROM 中段描述符的代码.

                        KERNEL_DS 属于 数据段描述符 而不属于 系统段描述符.

                        KERNEL_CS ==> 内核代码段描述符

                        KERNEL_DS ==> 内核数据段描述符

                        USER_CS ==> 用户代码段描述符

                        USER_DS ==> 用户数据段描述符
        
        系统段描述符  ==> 此描述符代表一个系统段,Type 的值代表了是哪一种系统段,S = 0

                        局部描述符表描述符 LDTD ==> 
                                代表一个包含有 LDT 的段,它只能保存在 GDT 中,相应的Type=2,S=0
                
                        任务状态段描述符 TSSD ==> 这个描述符代表一个任务状态段(TSS),
                                这个段用于保存部分CPU 寄存器的内容(内核态栈地址和 IO 许可权限位),它只保存在 GDT 中,根据相应的进程是否正在 CPU 上运行.其Type=11或9;S=0.



        注意并不是内核用的段就是系统段,这里的系统段的区分不是我们用户态和内核态的这种划分.而是根据 Segment descriptor 的 S 位 区别开.


        所有的用户进程都是使用同一个用户代码段描述符和用户数据段描述符,它们是 USER_CS 和 USER_DS,
        也就是每个进程处于用户态时,它们的 CS 寄存器和 DS 寄存器中的值是相同的.
        当任何进程或者中断异常进入内核后,都是使用相同的内核代码段描述符和内核数据段描述符,它们是
        KERNEL_CS 和 KERNEL_DS.
        这里要明确记得,内核数据段实际上就是内核态堆栈段.

        KERNEL_CS | KERNEL_DS | USER_CS | USER_DS 这几个段的BASE都是0x00000000,LIMIT都是
        0xfffff,并且G=1.所以这四个段它们的寻址空间为(4 GB) 0x0 ~ 0xFFFFffff. 这就是为什么所有
        进程都可以使用同一个用户代码段和用户数据段的条件.
        
        并且很清楚地可以看出来, KERNEL_CS | KERNEL_DS 都需要 CPL=0 时才能访问, USER_CS | 
        USER_DS 需要CPL=0~3 都可以访问.

        Linux 的处理
        KERNEL_CS | KERNEL_DS | USER_CS | USER_DS 的 segment descriptor 的 TI=0 ,说明
        都保存在 GDT 中, 这里有个疑问？为什么在linux kernel, 用户段的RPL=3,那么怎么去访问 
        DPL=0的内核段呢? linux 的确是禁止用户态访问内核态数据, 但是内核为用户态开了两个小门,然后
        用户态能够通过这两个小门进入到内核态中,(system call & 中断和异常).




   4. 段选择符 segment seltor (又称=> 段选择子),是一个 16 bit 标识符,它指向段描述表中定义段的段描述
      符(中介,不直接指    向段).

      主要作用 ===> 根据 段索引(Index)和 TI,去 GDT 和 LDT 中找到 segment seltor 对应的 segment descriptor.

      我们在内核代码中常见的__KERNEL_CS,__KERNEL_DS,__USER_CS,__USER_DS就是段选择符,它们并不是段描述符.

      segment seltor 只保存在 6 个段寄存器中; segment descriptor 只保存在 GDT | LDT 的表数组中

      正确的套路: 
             1 ==> 从 6 个 段寄存器 (CS|SS|DS) 中获取 segment seltor ;
             2 ==> 从 segment seltor 获取 index 和 TI 字段, 去 GDT | LDT 查 segment        
                   descriptor;
             3 ==> CPU 会自动将 segment descriptor 保存到 对应寄存器的非编程寄存器中.


    
      A: ===> RPL (Request Privilege Level) 请求特权级  2 bit; 提供了段保护信息

      B: ===> TI  (Table Index) 表指示标志 1 bit;  TI = 0 表示在 GDT 中, TI = 1 表示在 LDT 中
     
      C: ===> Index  段描述符的索引值    high 13 bit; 表示在 GDT 或 LDT 表中的索引号.  
              段选择子像一个中介一样通过"索引"段表(GDT|LDT)中的一个具体的段描述符结构来指定一个具体
              的段,并且描述符中包含了访问这个段的所有信息(段的基址,段的长度,段的属性).
      D: ===> 对应用程序来说段选择子是作为指针变量的一部分而可见,但选择子的值通常是由链接编辑器或链接加
              载程序进行设置或修改,而非应用程序.

      E: ===> 为减少地址转换时间和编程复杂性,CPU 提供可存放最多6个段选择符的寄存器,即段寄存器.
              每个段寄存器支持特定类型的内存引用(代码,数据,或堆栈).原则上执行每个程序都起码需要把有
              效的段选择符加载到代码段(CS),数据段(DS),堆栈段(SS)寄存器中.
              
      F: ===> 对于访问某个段的程序,必须已经把段选择符加载到一个段寄存器中.因此,尽管一个系统可以定义很多
              的段,但同时只有6个段可供立即访问.若要访问其他段就需要加载这些段的选择符.

      G: ===> 为了避免每次访问内存时都去引用描述符表,去读和解码一个段描述符,每个段寄存器都有一个“可见
              部分和一个“隐藏”部分(隐藏部分也被称为“描述符缓冲” 或 “影子寄存器”). 当一个段选择符被加
              载到一个段寄存器可见部分中时, CPU 也同时把段选择符指向的段描述符中的段地址,段限长以及访
              问控制信息加载到段寄存器的隐藏部分中.  缓冲在段寄存器(可见和隐藏部分)中的信息使得 CPU
              可以在进行地址转换时不再需要花费时间从段描述符中读取基地址和限长值.

      H: ===> 由于影子寄存器含有描述符信息的一个copy,因此 kernel 必须确保对描述符表的改动应反映在影子
              寄存器中.否则描述符表中一个段的基地址或限长被修改过,但改动却没有反映到影子寄存器中.
              处理这种问题最简洁的方法是在对描述符表中描述符作过任何改动之后就立刻加载6个段寄存器.
              这将把描述符表的相应信息重新加载到影子寄存器中.

              1: ==> 显式加载指令 ==> 为加载段寄存器,提供了两类加载指令:  MOV , POP,LDS, LES,
                     LSS,LGS 以及LFS 指令.这些指令显式地直接引用段寄存器.
              2: ===> 隐式加载指令,例如使用长指针的CALL ,JMP 和RET 指令, IRET ,INTn ,INTO 和
                     INT3 等指令.这些指令在操作过程中会附带改变 CS 寄存器(和某些其他段寄存器)的内容.





    内存管理寄存器

    1: ==> CPU 提供了4个内存管理寄存器(GDTR,LDTR,IDTR 和 TR),用于指定分段内存管理所使用的系统表的
           基地址,见面图4-2所示. CPU为这些寄存器的加载和保存提供了特定的指令.
    
    2: ==> GDTR,LDTR,IDTR,TR 都是段基址寄存器,这些段中含有分段机制的重要信息表. 

           GDTR, IDTR 和 LDTR 用于寻址存放描述符表的段.
           
           TR 用于寻址一个特殊的任务状态段 TSS.

           TSS ===> Task State Segment 包含着当前执行任务的重要信息(一个特殊的任务状态 段).
    
    3: ==> 全局描述表寄存器 GDTR : 用于存放全局描述符表GDT 的32 bit 线性基地址 和 16 bit 表长度值.
           
           整个系统中, GDT 只有一个(一个 CPU 对应一个 GDT), GDT 可以被放在内存的任何位置,但 cpu 必
           须知道 GDT 的入口,也就是基地址放在哪里. GDTR 寄存器专门用来存放 GDT 的入口地址, 程序员
           将 GDT 设定在内存中某个位置之后,可以通过 LDTR 指令将 GDT 入口地址装入该寄存器. GDTR 存放
           的是 GDT 的基地址和表长度.

           基地址指定 GDT 表中字节 0 在线性地址空间中的地址,表长度指明GDT 表的字节长度值. 指令LGDT 
           和SGDT 分别用于加载和保存GDTR 寄存器的内容. 在机器刚加电或CPU复位后,基地址被默认的设置为0,
           而长度值被设置成 0xFFFF. 在保护模式初始化过程必须给GDTR加载一个新值.

    4: ==> 中断描述符表寄存器 IDTR : 与GDTR的 作用类似,IDTR 寄存器用于存放中断描述表 IDT 的32 bit 
           线性基地址 和 16bit 表长度值.
           
           汇编指令 LIDT 和 SIDT 分别用于加载和保存 IDTR 寄存器的内容. 在机器刚加电或CPU复位后, 基
           地址被默认的设置为0,而长度值设置为 0xFFFF.

           

    5: ==> 局部描述符寄存器 LDTR : 用于存放 16bit 段选择子 以及 局部描述表 LDT 的32 bit 线性基地址
           和 16 bit 段限长描述符属性值.

           指令 LLDT 和 SLDT 分别用于加载和保存 LDTR 寄存器的段描述符部分.包含 LDT 表的段必
           须在 GDT 表中有一个段描述符项. 
           
           当使用 LLDT 指令把含有 LDT 表段的选择符加载进 LDTR 时, LDT 段描述符的段基地址,段限长度以
           及描述符属性会被自动地加载到 LDTR 中,当进行任务切换时候,段选择符 和 基地址被默认地设置为0 ,
           而长度被设置为0xffff.

           但是 LDTR 与 GDTR 寄存器的存储内容不同, LDTR 存储的内容是一个段选择子. 

           由于 LDT 本身同样是一段内存,也就是一个段,所以它也有个描述符描述它, 这个描述符就存储在 GDT
           中,对应这个表描述符 也会有一个选择子, LDTR 装载的就是这样的一个选择子.

           LDTR 可以在程序中随时的改变, LLDT.

           由于每个进程都有自己的一套程序段、数据段、堆栈段,有了 LDT 则可以将每个进程的程序段、数据段、
           堆栈段封装在一起,只要改变 LDTR 就可以实现对不同进程的段进行访问.

           当进行任务切换时,CPU 会把新任务 LDT 的段选择符和段描述符自动地加载进 LDTR 中.
           

    6: ==> 任务寄存器TR : 用于存放当前任务 TSS 段的 16 bit 段选择符,32 bit 基地址, 16bit 段长度和
            描述符属性值.  它引用 GDT 表中的一个 TSS 类型的描述符.  汇编指令 LTR 和 STR 分别用于加
            载和保存 TR 寄存器的段选择子部分.   当使用 LTR 指令把选择子加载进 TR 任务寄存器时候,TSS 
            描述符中的段基地址,段限长度以及描述符属性会被自动地加载到 TR 寄存器中. 当执行任务切换时,处
            理器会把新任务 TSS 的段选择符和段描述符自动地加载进任务寄存器 TR 中.


    分段机制: Inter 的 CPU 提供了分段功能,虽然现代操作系统不使用分段机制(linux/xnu),但是分段机制属于
    CPU 的一个功能, linux 不使用,也要通过代码想办法绕过它,况且 linux 也使用到了分段机制中的某些功能.

    分段机制主要功能只有两点:
    1.==> 将物理内存划分为多个段,让操作系统可以使用大于其地址线对应的物理内存.
    2.==> 权限控制,将每个段设置权限位,让不同的程序访问不同的段.

    对于 Linux kernel 来说,它仅仅只使用了分段机制中的权限控制功能. 它的做法如下:

    1 ===> CPU 段寄存器
           在 CPU 中, 跟段有关的 CPU 寄存器一共有 6 个 : CS , SS, DS, ES, FS, GS.
           
           它们保存的是段选择子 16 bit.

           而同时这 6 个寄存器每个都有一个对应的非编程寄存器, 它们对应非编程寄存器中保存的是段描述符.
           系统可以把同一个寄存器用于不同的目的,方法是先将其寄存器中的值保存到内存中,之后恢复. 
           CS, DS , SS 这三个寄存器一般会这样使用.

           1 ===> CS 代码段寄存器: 指向包含程序指令的段,在 CS 寄存器中 RPL 用于表示当前 CPU 的特权
                  级(CPL), CPL 为 0 是最高权限(内核态使用),CPL 为 3是用户态使用.

           2 ===> SS 栈段寄存器: 指向当前程序的栈的段.

           3 ===> DS 数据段寄存器: 指向保存着静态数据和全局数据的段(静态区).


        

  2 ===> 逻辑地址是由 segment seltor (16 bit) + segment offset(32 bit) 得来.
         只有处于用户态, CS & DS 中的值都是 USER_CS & USER_DS.
         只要处于内核态, CS & DS 中的值都是 KERNEL_CS & KERNEL_DS.

         我们在编程过程中,实际上提供的地址都是一个 offset, 系统会自动将这个 offset 与 CS 中
         的 segment seltor 进行结合.   也就是说我们使用的逻辑地址实际上只使用了 offset 这
         一段, segment seltor 都是空.     之前说的 KERNEL_CS | KERNEL_DS | USER_CS | USER_DS 4 个段描述符的 BASE=0x0, 也得出当逻辑地址通过这样的分段机制 转为线性地址后,
         实际上并没有变化, 也就说是 逻辑地址=线性地址(其实这两个地址都是 offset 的值).

         也可以看出来,每次进行地址转换时都要通过 segment descriptor 获取 segment base 然后与
         offset 运算得到 line address 线性地址.     而 segment descriptor 是保存在内存当中的,
         这样每次转换难道就要访问一次内存或者cache吗？当然不是,之前说到一共有6种段寄存器,它们每个都有属
         于自己的一个非编程寄存器,专门用于存放现在的segment descriptor,比如 CS 段寄存器说,CS 存放的
         是 segment seltor ,所以每次通过 logic address 逻辑地址访问这个段里的内容时,都要通过这个 segment seltor 与 GDTR(TI=0) 或者 LGTR (TI=1) 结合然后从内存中得到对应的segment descriptor,然后根据 segment descriptor 的 BASE 和 LIMIT 将逻辑地址转换为线性地址.

         如果进行连续访问时(而且连续访问的概率非常高),这样的效率就非常低了.优化方法==> CS段寄存器对应的非编程寄存器就是用于保存这个段描述符的,这样就不用每次都从内存中获取segment descriptor,而是直接从这个 CS 对应的非编程寄存器中获取segment descriptor.



/*********************************************************************************/

 3 ===> 发生段切换有两种情况:  1===> system call  2===> Interrupt | exception
        
        中断异常发生 系统的变化如下~~~

        这里只说明系统大多数发生的情况,不讨论个例.
/*********************************************************************************/
        假定当前系统处于用户态执行代码中,这时候各个段寄存器的值应该是这样的:

        CS: USER_CS
        DS: USER_DS
        SS: 保存着用户态栈基地址
        ESP: 保存着用户态栈顶地址
        EIP: 保存下条将要执行的指令地址

        当中断或异常发生时,CPU会按照如下步骤进行执行:

        读取由 IDTR 寄存器保存的 IDT (中断向量表)中对应的(gate)门描述符.
        
        根据对应的门描述符,获取其中保存的段选择符.(门描述符中保存有一个段选择符和一个门的DPL,这两个部分
        是段切换的重要部分.

        根据这个段选择符获取对应的段描述符(门描述符中保存的段选择符基本都是 KERNEL_CS).

        这时 CPU 会使用 CS 寄存器中的 CPL 特权级与获取的段描述符的 DPL 特权级比较,如果 DPL<= CPL,则通过,否则产生“通用保护”异常,我们也看到, CS 保存的是 USER_CS,其 CPL=3,门描述符中保存的是 KERNEL_CS,其 DPL=0;也就是会通过检查.
        
        如果是异常情况,这时还会多一步进行检查,会检查门描述符中的 DPL特权级,当前特权级 CPL 的值 > DPL 的值时,则通过检查,否则不能通过检查,而只有系统门和系统中断门的 DPL=3,其他的异常门的DPL=0.

        这样做的好处是避免了用户程序访问陷阱门、中断门和任务门.到这里检查已经通过,如果特权级发生变化(用户态产生的中断和异常,肯定会发生特权级变化),则 CPU 会自动帮切换不同特权级使用的寄存器.

        从 TR 寄存器中获取 CPU 的 TSS 段描述符,从 TSS 段描述符中获取当前进程的内核态堆栈指针和 SS 寄存器的值并将它们装载到 SS 和 EIP 寄存器.  在当前进程的内核栈中保存用户态的 SS 寄存器和 EIP寄存器的值.(注意,这里是先装载了 SS 和 EIP 寄存器,让其指向内核栈,再在内核栈中保存用户态的 SS 和 EIP 寄存器值)如果故障已经发生,用引起异常的指令地址装载到 CS 和 EIP 寄存器,从而使这条指令再次被执行.

        在内核栈中保存用户态的 eflags、CS 和 EIP .CS 和 EIP 的值就是返回后的下一条指令地址.如果有硬件出错码,也保存到内核栈中.从中断向量表的门中获取 CS 和 EIP 值并装载到 CS 和 EIP 寄存器.门中保存的 CS 和 EIP 合起来就会是中断处理程序入口地址.

/*********************************************************************************/
        这些步骤执行完后,寄存器变化为:

        CS: KERNEL_CS
        DS: USER_DS
        SS: 保存着内核态栈基地址
        ESP: 保存着内核态栈顶地址
        EIP: 保存着中断处理程序入口地址


        而内核栈中保存的值有:用户态CS,用户态SS,用户态ESP,用户态EIP,用户态 eflags.
        
        当系统从中断返回用户态时,就会从内核栈中将这些值还原,最后会回到进入时的情况.
        至于为什么不用修改DS寄存器的值,我也不清楚??????

/*********************************************************************************/

一致性代码段和非一致性代码段

        1 ===> CPL(Current Priviliege Level):它代表了当前代码段的特权等级,由 CS 和 SS的第 0 
                位 和第 1 位表示.
                当程序转移到不同的特权等级的代码时处理器将改变CPL.
                在遇到一致代码段时,一致代码可以被相同或者更低特权等级（用户程序）的代码访问.
                当处理器访问一个与 CPL 特权等级不同的一致代码段时,CPL不会被改变.
        
        2 ===> DPL（Descriptor Priviliege Level):表示段或者门的特权等级,它存储在段或者门描述符的
                DPL字段中.
                每当当前代码段试图访问一个段或者门时, DPL 将会和 CPL 以及 RPL 作比较,根据段或者门
                类型的不同, DPL 将会被区别对待: 
                
                数据段: DPL 规定了可以访问此段的最低特权等级. 
                
                非一致代码段（不使用调用门的情况下）: DPL 规定了访问此段的特权级;调用门:与数据段一致.
                
                一致代码段和通过调用门访问的非一致代码段: DPL 规定了访问此段的最高特权等级. 
                
                TSS:与数据段一致.

        3 ===> RPL（Requested Priviliege Level):RPL是通过选择子的第0位和第1位来表示的.处理器通过
                检查RPL和CPL来确认一个访问请求是否合法.即使提出请求的段有足够的特权级,如果RPL不够也是
                不行的.也就是说,如果RPL的数字比CPL大,那么RPL将会起决定作用,反之亦然. 

/*********************************************************************************/

        对于一致代码段:也就是共享的段.
                特权级高的程序不允许访问特权级低的数据:核心态不允许调用用户态的数据.
                特权级低的程序可以访问到特权级高的数据.但是特权级不会改变:用户态还是用户态.

        对于普通代码段.也就是非一致代码段:
                只允许同级间访问.
                绝对禁止不同级访问:核心态不用用户态.用户态也不使用核心态.

/*********************************************************************************/


# https://blog.csdn.net/liutianshx2012/article/details/52347544

控制寄存器 ===> CR0 | CR 1 | CR 2 | CR3 ,用于控制和确定 CPU 的 MODE 以及当前执行任务的特性,
              CR0 含有控制 CPU 操作 Mode 和 state 的系统控制状态;
              CR1 保留不用;
              CR2 含有导致页错误的 linear address.
              CR3 含有页目标表物理内存基地址,因此该寄存器页被称为页目录基地址寄存器 PDBR (Page 
              Directoy Base  address Register).


              CRO 32bit 寄存器 , PE 在 0 bit 开启保护标志; PG 在 31bit 分页标志.

              PE = 1 ==> Segment protect mode 分段机制
              PE = 1 & PG=1 ==> Paging mode 分页机制; 
              PG=0, linear address == physical address



             CR2 & CR3 用于分页机制. 


/*********************************************************************************/

门描述符结构 https://blog.csdn.net/liutianshx2012/article/details/52525522

任务门用于任务切换; 陷阱门和中断门是调用门的特殊类,专门用于调用异常和中断的处理程序.