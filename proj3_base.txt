# proj3 

1. 理解虚拟内存的 Page Fault 异常处理实现;
2. 理解 页替换算法在 OS 中的实现;


Content
1. 在 proj2的基础上,借助于页表机制和 proj1 涉及的中断异常处理机制,
完成 Page Fault异常处理和 FIFO 页替换算法的实现;

2. 结合磁盘提供的缓存空间,从而能够支持虚存管理,提供一个比实际无聊内存空间“更大”的
虚拟内存空间给系统使用;

3. proj3 的算法实现比 实际应用的OS 中的实现比较起来更简单;

4. 实际操作系统中的虚拟内存管理设计与实现是相当复杂的,涉及到与进程管理系统、文件系统
等的交叉访问.

/********************************************************************/

首先,在有了分页机制后,程序员或CPU“看到”的地址已经不是实际的物理地址了,这已经有一层虚拟化,我们可简称为内存地址虚拟化.有了内存地址虚拟化,我们就可以通过设置页表项来限定软件运行时的访问空间,确保软件运行不越界,完成内存访问保护的功能.

其总体设计思路还是比较简单
1==>  首先完成初始化虚拟内存管理机制,即需要设置好哪些页需要放在物理内存中,哪些页不需要放在物理内存中,而是可被换出到硬盘上,并涉及完善建立页表映射、页访问异常处理操作等函数实现.

2==> 然后就执行一组访存测试,看看我们建立的页表项是否能够正确完成虚实地址映射,是否正确描述了虚拟内存页在物理内存中还是在硬盘上,是否能够正确把虚拟内存页在物理内存和硬盘之间进行传递,是否正确实现了页面替换算法等.
/********************************************************************/


/********************************************************************/

##  Page Fault 异常处理

实现虚存管理的一个关键是 page fault异常处理,其过程中主要涉及到函数 -- do_pgfault的具体实现.比如,在程序的执行过程中由于某种原因(页框不存在/写只读页等)而使 CPU 无法最终访问到相应的物理内存单元,即无法完成从虚拟地址到物理地址映射时,CPU 会产生一次页访问异常,从而需要进行相应的页访问异常的中断服务例程.这个页访问异常处理的时机被操作系统充分利用来完成虚存管理,即实现“按需调页”/“页换入换出”处理的执行时机.当相关处理完成后,页访问异常服务例程会返回到产生异常的指令处重新执行,使得应用软件可以继续正常运行下去.


具体而言,当启动分页机制以后,如果一条指令或数据的虚拟地址所对应的物理页框不在内存中或者访问的类型有错误(比如写一个只读页或用户态程序访问内核态的数据等),就会发生页访问异常.产生页访问异常的原因主要有：

1===>  目标页帧不存在(页表项全为0,即该线性地址与物理地址尚未建立映射或者已经撤销)；

2===>  相应的物理页帧不在内存中(页表项非空,但Present标志位=0,比如在swap分区或磁盘文件上);

3===>  不满足访问权限(此时页表项P标志=1,但低权限的程序试图访问高权限的地址空间,或者有程序试图写只读页面).


    当出现上面情况之一,那么就会产生页面 page fault(#PF)异常.

    CPU会把产生异常的线性地址存储在 CR2 中,并且把表示页访问异常类型的值(简称页访问异常错误码,errorCode)保存在中断栈中.

    [warning 1]页访问异常错误码有32位.位0为１表示对应物理页不存在；位１为１表示写异常(比如写了只读页；位２为１表示访问权限异常(比如用户态程序访问内核空间的数据);

    [warning 2]　CR2 是页故障线性地址寄存器,保存最后一次出现页故障的全32位线性地址.
                CR2用于发生页异常时报告出错信息.当发生页异常时,处理器把引起页异常的线性地址保存在CR2中.OS 中对应的中断服务例程 (ISR)可以检查CR2的内容,从而查出线性地址空间中的哪个页引起本次异常.+

    产生页访问异常后,CPU 硬件和软件都会做一些事情来应对此事.
    
    首先页访问异常也是一种异常,所以针对一般异常的硬件处理操作是必须要做的,即CPU在当前内核栈保存当前被
    打断的程序现场,即依次压入当前被打断程序使用的 EFLAGS,CS,EIP,errorCode；
    
    由于页访问异常的中断号是 0xE,CPU 把异常中断号 0xE 对应的中断服务例程的地址(vectors.S中的标号vector14处)加载到CS和EIP寄存器中,开始执行中断服务例程. 
    
    这时 kernel 开始处理异常中断,首先需要保存硬件没有保存的寄存器.在vectors.S中的标号vector14处先把中断号压入内核栈,然后再在trapentry.S中的标号__alltraps处把DS、ES和其他通用寄存器都压栈.自此,被打断的程序执行现场(context)被保存在内核栈中.接下来,在trap.c的trap函数开始了中断服务例程的处理流程,大致调用关系为： 
    
    trap--> trap_dispatch-->pgfault_handler-->do_pgfault

    产生页访问异常后,CPU 把引起页访问异常的线性地址装到寄存器 CR2 中,并给出了出错码 errorCode,说明了页访问异常的类型.   kernel 会把这个值保存在 struct trapframe 中 tf_err 成员变量中.
    
    而中断服务例程会调用页访问异常处理函数 do_pgfault 进行具体处理. 这里的页访问异常处理是实现按需分页、页换入换出机制的关键之处.

    kernel 中 do_pgfault 函数是完成页访问异常处理的主要函数,它根据从 CPU 的控制寄存器 CR2 中获取的
    页访问异常的物理地址以及根据 errorCode 的错误类型来查找此地址是否在某个 VMA 的地址范围内以及是否
    满足正确的读写权限,如果在此范围内并且权限也正确,这认为这是一次合法访问,但没有建立虚实对应关系.
    
    所以需要分配一个空闲的内存页,并修改页表完成虚地址到物理地址的映射,刷新TLB,然后调用 iret 中断,返回到产生页访问异常的指令处重新执行此指令.  如果该虚地址不在某 VMA 范围内,则认为是一次非法访问.
    
/********************************************************************/
