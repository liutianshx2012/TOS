# proj 2
/************************************************************************/


# 实验执行流程概述

  proj2 主要完成了 os kernel 对物理内存的管理工作. 总控函数 kern_init(). 
  
  首先, bootloader 的工作有增加 , 在 bootloader 中, 完成了对物理内存资源的探测工作,让 os
  kernel 在后续执行中能够基于 bootloader 探测出的物理内存情况进行物理内存管理初始化工作.

  其次, bootloader 不像 proj1 那样,直接调用 kern_init(), 而是先调用 kern_enty函数 (汇编),
  kern_enty() 的主要任务是为了执行 kern_init() 建立一个良好的 C 语言运行环境(设置堆栈),而完成这些
  工作后,才调用 kern_init().


   为了完成物理内存管理,这里首先需要探测可用的物理内存资源; 了解到物理内存位于什么地方 ？ 有多大
   之后,就以固定页面大小来划分整个物理内存空间,并准备以此为最小内存分配单位来管理整个物理内存,管理
   在内核运行过程中每页内存,设定其可用状态(free | used | reserved),这其实就对应了我们在课本上讲
   到的连续内存分配概念和原理的具体实现;   接着 os kernel 就要建立页表,启动分页机制,让 CPU 的 
   MMU 把预先建立好的页表中的页表项 PTE 读入到 TLB 中,根据页表项 PTE 描述的虚拟页 (Page)与
   物理页帧(Page Frame) 的对应关系完成 CPU 对内存的读写和执行操作.  

   这一部分其实就对应了我们在课本上讲到内存映射、页表、多级页表等概念和原理的具体实现.

   1 ==> 初始化物理内存页管理器框架 pmm_manager ;
   2 ==> 建立空闲的 page 链表, 这样就可以分配以页 4kb 为单位的空闲内存了;
   3 ==> 检查物理内存页分配算法;
   4 ==> 为确保切换到分页机制后,代码能够正常执行,先建立一个临时二级页表;
   5 ==> 建议一一映射关系的二级页表;
   6 ==> 使能分页机制;
   7 ==> 从新设置全局段描述符表;
   8 ==> 取消临时二级页表;
   9 ==> 检查页表建立是否正确;
   10 ==> 通过自映射机制完成页表的打印输出.

/************************************************************************/
/************************************************************************/

/****************************************************************************/

### 1 ===> 探测物理内存分布和大小的方法

OS kernel 需要知道了解整个计算机系统中的物理内存如何分布, 哪些可用,哪些不可用.
基本方法是通过 BIOS 中断调用来帮助完成的. 其中 BIOS 中断调用必须在实模式下进行,
所以在 bootoader 进入保护模式前完成这部分工作相对比较合适. 
这部分功能由 boot/bootasm.S 中  probe_memory ~~~~~ finish_memory 处的代码
完成. 
通过 BIOS 中断获取内存可调用参数为 0xE820 的 INT 0x15 号 BIOS 中断.
BIOS 通过系统内存映射描述符 (Address Range Descriptor) 格式来表示系统物理内存布局:

offset           size         Descriptor
00h              8byte        # 系统内存块基地址
08h              8byte        # 系统内存大小
10h              4byte        # 内存类型 


/****************************************************************************/


### 2 ===> 以页为单位管理物理内存

## struct Page

在获得 available physical addr 范围后,系统需要建立相应的数据结构来管理 以物理页(4kb 对齐,4kb 大小)
为最小单位的整个物理内存, 以配合后续涉及的分页管理机制. 每一个物理页可以用一个 struct Page 来表示. 由
于一个物理页需要占用一个 struct Page 的内存空间, struct Page 设计时必须尽可能的小.
以页为单位的物理内存分配管理的实现算法在 kern/default_pmm.

为了与以后的分页机制配合,需要先建立对整个计算机的每一个物理页的属性 struct Page ,包含了映射此物理页的
虚拟页个数 ref;描述物理页属性的 flags 和 双向链接各个 struct Page 的 page_link 双向链表.


## struct free_area_t

   在初始情况下,也许物理内存的空闲物理页都是连续的,这样就形成一个大的连续内存空闲块.
   但伴随着物理页的分配与释放,这个大的连续内存空闲块会分裂为一系列地址不连续的多个小的连续内存空闲
   块,并且每个连续内存空闲块内部的物理页是连续的.
   
   那么为了有效地管理这些小连续内存空闲块,所有的连续内存连续空闲块可用一个 双向链表管理起来,
   便于分配和释放,为此定义了一个 struct free_area_t ,包含了一个 
   list_entry_t 的双向链表指针(指向了空闲的物理页).


有了这两个数据结构, kernel 就可以管理起来整个 以 Page 为单位的物理内存空间. 接下来需要解决两个问题:

  A : ===> 管理页级物理内存空间所需的 struct Page 的内存空间从哪里开始,占用多大空间？
  B : ===> 空闲内存空间的起始地址在哪里？

  对于这两个问题,我们首先根据 bootloader 给出的内存布局信息找出最大的物理内存地址 maxpa (定义在 
  page_init 函数中的局部变量),由于 x86 的起始物理内存地址为 0, 所以可以得知需要管理的物理页个数为  
  
                  npage = maxpa / PAGE_SIZE;

  这样,我们就可以预估出 管理页级物理内存空间所需的 struct Page 的内存空间所需的 内存大小为

                  sizeof(struct Page) * npage;

   由于 bootloader load kernel elf 的结束地址(用全局指针变量 end 记录)以上的空间没有被使用,所以我
   们可以把 end 按 Page 大小为边界取整后,作为管理页级物理内存空间所需的 struct Page 的内存空间, 记
   为:
   
            pages = (struct Page *)ROUNDUP ((void*)end, PAGE_SIZE);


   为了简化,从 addrA =0 到 addrB = pages + sizeof(struct Page) * npage 结束的物理内存空间设定
   为已占用物理内存空间 (起始 0 ~ 640KB 的空间是空闲的), addrB 以上的空间为空闲物理内存空间,这时的空
   闲空间起始(物理)地址为
   
   uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * npage);

   为此我们需要把这两部分空间给标识出来.首先,对于所有物理空间,通过下面的代码实现占用标记 :

    for (i=0;i<npage;i++) {
        SetPageReserved(pages + i);
    }

    然后,根据探测到的空闲物理空间,通过下面语句实现空闲标记:

    for (i=0;i<memmap->nr_map;i++) {
        uint64_t begin = memmap->map[i].addr;
        uint64_t end = begin + memmap->map[i].size;
        if (memmap->map[i].type == E820_KERN) {
            if (begin < freemem) {
                begin = freemem;
            }
            if (end > KMEMSIZE) {
                end = KMEMSIZE;
            }
            if (begin < end) {
                begin = ROUNDUP(begin, PAGE_SIZE);
                end = ROUNDDOWN(end, PAGE_SIZE);
                if (begin < end) {
                    // [001b9000, 07fe0000]
                    // cprintf("begin~end [%08llx, %08llx]\n",begin,end);
                    // 根据探测到的空闲物理空间,设置空闲标记,获得空闲空间的起始地址和结束地址
                    init_memmap(pa2page(begin), (end - begin) / PAGE_SIZE);
                }
            }
        }
    }

    SetPageReserved 宏只需把物理地址对应的 Page 结构中的 flags 标志设置为 PG_reserved,
    表示这些 page 已经被使用了,将来不能被用于分配.  而 init_memmap 函数则是把空闲物理页对应
    的 struct Page 中的 flags 和 ref = 0,并加到 free_area.free_list 指向的双向列表中,
    为将来的空闲页管理做好初始化准备工作.

    关于内存分配的 os 原理的知识很多,但是在 proj2 中只实现了最简单的内存页分配算法.  相应的实现
    在 default_pmm.c 中的 default_alloc_pages 函数和 deafault_free_pages 函数,相关实现
    很简单. 直接看源码,应该很好理解.

/****************************************************************************/
/****************************************************************************/

### 物理内存页分配算法实现

  要在 os kernel 中实现连续物理内存分配算法,则需要考虑的事情比较多,想对课本上的物理内存分配算法
  描述要复杂不少. 

  下面介绍一下如果要实现一个 First-fit 内存分配算法得大致流程.

  proj 2 的第一部分是完成 First-fit 的分配算法. first-fit 算法原理很简单.

  First-fit 分配算法需要维护一个查找有序(addr 按照 从小到大排列) 空闲块 (以 page 为最小单位的整
  个物理内存连续地址空间) 的数据结构,而双向链表是一个很好的选择.

typedef struct {
    list_entry_t free_list;//空闲块双向链表的头; the list header 
    unsigned int nr_free;  //记录当前空闲页的个数; # of free pages in this free list
} free_area_t;

 显然,我们可以通过此数据结构来完成对空闲块的管理. 而 default_pmm.c 中定义 free_area_t free_area 变量就是干这个事情的;




#### first-fit 设计实现

default_init_memmap 函数将根据每个物理页帧的情况来建立空闲页链表,且空闲页块应该是
根据地质高低形成一个有序链表.

static void
default_init_memmap(struct Page *base, size_t n)
{
    assert(n > 0);
    struct Page *p = base;
    for (; p != base + n; p ++) {
        assert(PageReserved(p)); //确认本页是否为保留页
        p->flags = 0; 	//设置标志位
        SetPageProperty(p);
        p->property = 0;
        set_page_ref(p, 0); //清空引用
        list_add_before(&free_list, &(p->page_link));//插入空闲页的链表里面
    }
    nr_free += n;//说明连续有n个空闲块,属于空闲链表
    //first block
    base->property = n;//连续内存空闲块的大小为n,属于物理页管理链表
}

如果要分配一个页,那要考虑哪些呢？ 这里就需要考虑实现 default_alloc_pages 函数,注意参数 n 
表示要分配 n 个页. 另外需要尽量多考虑一些边界情况,这样确保软件的鲁棒性.

/* 
 * n : 需要分配 n 个 page.
 * 从空闲页块的链表中去遍历,找到第一块大小大于n的块,然后分配出来,把它从空闲页链表中除去,
 * 然后如果有多余的,把分完剩下的部分再次加入会空闲页链表中即可.
 * */
static struct Page *
default_alloc_pages(size_t n)
{
    assert(n > 0);
    //如果所有的空闲页的加起来的大小都不够,那直接返回NULL
    if (n > nr_free) {  
        return NULL;
    }
    list_entry_t *le = &free_list; //从空闲块链表的头指针开始
    list_entry_t *next_le;
    //依次往下寻找直到回到头指针处,即已经遍历一次
    while((le=list_next(le)) != &free_list) { 
        //将地址转换成页的结构
        struct Page *p = le2page(le, page_link); 
        //由于是first-fit,则遇到的第一个大于等于N的块就选中即可
        if(p->property >= n) {  
            int i;
            // 找到 first fit block 后,就要从新组织空闲块,然后把找到的 page 返回.
            for(i=0; i<n; i++) {
                next_le = list_next(le); //下一个空闲块
                struct Page *pp = le2page(le, page_link);//下一个空闲块对应的 page
                SetPageReserved(pp);
                ClearPageProperty(pp);
                list_del(le);
                le = next_le;
            }
            //如果分配的多了需要剔除
            if(p->property>n) {
                //如果选中的第一个连续的块大于n,只取其中的大小为n的块
                (le2page(le,page_link))->property = p->property - n;
            }
            ClearPageProperty(p);
            SetPageReserved(p);
            //当前空闲页的数目减n
            nr_free -= n;  
            return p;
        }
    }
    //没有大于等于n的连续空闲页块,返回空
    return NULL;
}

first-fit 需要从空闲链表头开始查找最小的地址,通过 list_next 找到下一个空闲块元素,通过 le2page
宏可以由链表元素获得对应的 Page 指针 p.

/****************************************************************************/
### 建立段页式管理中需要考虑的关键问题

为了实现分页机制,需要建立好 virtual memory 与 physical memory 的映射关系,即正确建立二级页表.
此过程涉及硬件细节,不同的地址映射关系组合,相对比较复杂.  总体而言,我们需要思考以下几个问题:

##### 1==> 如何在建立页表的过程中维护 GDT 和 Page Table 之间的关系, 确保 kernel 能够在
           各个时间段上都能正常寻址?

      2==> 对于哪些物理内存空间需要建立 页映射关系?

      3==> 具体的 页映射关系 是什么？

      4==> PDE 页目录表的起始地址设置在哪里？

      5==> PTE 页表的起始地址设置在哪里,需要多大的空间?

      6==> 如何设置 PDE 的内容?

      7==> 如何设置 PTE 的内容？

/****************************************************************************/

#### 建立虚拟页和物理页帧的地址映射关系
https://blog.csdn.net/liutianshx2012/article/details/52398144
## 页表项结构 (PDE & PTE)

1==> 分页转换功能由驻留在内存中的表来描述,该表称为页表(page table),存放在物理地址空间中.页表可以看作是简单的2^20 物理地址数组.线性地址到物理地址的映射功能可以简单地看作是进行数组查找.线性地址的高20bit 构成了这个数组的索引值,用于选择对应页面的物理(基)地址.线性地址的低12bit 给出了页面中的偏移量,加上页面的基地址最终形成对应的物理地址.由于页面基地址对齐在4K 边界上,因此页面基地址的低12 bit 肯定是0. 这意味着 高 20 bit的页面基地址 和 12 bit 偏移量连接组合在一起就能得到对应的物理地址.

2==> 页表中每个页表项大小为 32 bit. 由于只需要其中的20 bit来存放页面的物理基地址,因此剩下的12 bit 可以用于存储诸如页面是否存在等属性信息.如果线性地址索引的页表项被标注为存在的,则表示该项即有效,我们可以从中取得页面的物理地址.如果项中表明不存在,那么当访问对应物理页面时就会产生一个异常.

###  建立二级页表
         
由于我们已经具有了一个物理内存页管理器 default_pmm_manager, 我们就可以用它来获得所需的 free 
physical page. 在二级页表结构中,页目录表(PDT)占 4KB 空间, kernel 就可通过 alloc_page 函数获得
一个空闲物理页,这个页的起始物理地址就是 页目录表(PDT) 的起始地址.
    
同理,kernel 也通过这种方式获得 一个 页表(PT) 所需的 4KB 空间.

整个 PDT 和 PT 所占内存大小取决于 二级页表要管理和映射的 物理页数.
假设当前物理内存 0~ 16MB, 每个页帧(page frame) = 4kb,则用 16^20 / 4^10 = 4096 个物理页,也就意
味着有 4 个 PDE (Page Directory Entry) 和 4096 个 PTE(Page Table Entry) 需要设置. 每一个

PDE 和 PTE 大小均为 4B . 即使只有 4 个 PDE 也需要一个完整的 PDT(4kb) 装.  而 4096 个 PTE 需要 16kb (4096 * 4B),也就是 4 个 page frame.  

所以对 16MB 的物理页建立一一映射的 16MB 的虚拟页,需要 5 个物理页, 即 20KB 的空间来生成二级页表.


计算过程:

要映射物理内存 16MB , page frame size = 4KB , 能分配多少 page frame ?

step 1 ===>  16MB / 4KB = 4096 个 

每一个 page frame 需要 一个 PTE 描述, PTE size = 4B,存 4096 个 PTE 需要内存大小？

step 2 ===> 4096 * 4B = 16KB 

每一个 PT 能存 1024 个 PTE , 4096 个 PTE 需要多少个 PT 描述？ PT 需要内存大小 ？

step 3 ===> 4096 / 1024 = 4 个 ;  每个 PT 占4KB  4 * 4KB = 16KB 

每一个 PDT 能存 1024 个 PDE , 每一个 PDE 描述一个 PT , 4 个 PT 需要 1个 PDT .
描述 4096 个 page frame 需要 1个 PDT , 4个 PT 

step 4 ===> 4KB + 4KB * 4 = 20KB 



为了把 0 ~ KMEMSIZE (0x38000000 = 896MB, 代入上面公式 n = 229375 个 page frame.) 的物理
内存一一映射到 PDE 和 PTE 的内容,其大致流程如下:

1 ==> alloc_page 获得一个 free page frame, 用于 PDT (4kb);

2 ==> boot_map_segment 建立一一映射关系,具体处理过程以 page frame 为单位进行设置,即 
      
      virtual addr = phy addr + 0xC000 0000

      设一个 32bit linear addr la 有一个对应的 32bit phy addr pa, 如果以 la 的 high 10bit 
      为索引值的 PDT 中存在位 PTE_P=0, 表示缺少对应的 PT 空间,则需要 alloc_page 获得新的一个 
      free page frame 给 PT, PT 的起始 phy addr 是 4kb 对齐,这样填写 PDE 的内容为

      页目录项内容 = (页表起始物理地址 & ~0xfff)| PTE_U | PTE_W | PTE_P 

      进一步对于 PT 中以 linear addr la 中10bit 为索引值 对应 PTE 的内容为

      页表项内容 = (pa & ~0xfff)| PTE_W | PTE_P 

3 ==> PTE_U: 位3,表示用户态的软件可以读取对应地址的物理内存页内容

4 ==> PTE_W: 位2,表示物理内存页内容可写

5 ==> PTE_P: 位1,表示物理内存页存在


有一点需要注意,在页目录表 PDT 和 页表 PT 中存放的地址都是物理地址, 但是 PDT 与 PT 本身是 用 虚拟地址描述

 +--------10------+-------10-------+---------12----------+
 | Page Directory |   Page Table   | Offset within Page  |
 |      Index     |     Index      |                     |
 +----------------+----------------+---------------------+
 |--- PDX(la) ----|---- PTX(la) ---|---- PGOFF(la) ------|
 |----------- PPN(la) -------------|

pde_t 全称为page directory entry,也就是一级页表的表项(注意:pgdir实际不是表项,而是一级页表本身,pgdir给出页表起始地址.)
pte_t 全称为page table entry,表示二级页表的表项.
uintptr_t 表示为线性地址,由于段式管理只做直接映射,所以它也是逻辑地址.


虚拟地址只有映射上了物理页才可以正常的读写.在完成映射物理页的过程中,除了要像上面那样在页表的
对应表项上填上相应的物理地址外,还要设置正确的控制位.有关 x86 中页表控制位的详细信息清参考
<<Intel 64 and IA-32 Architectures Software Developer's Manual -Volume 3A>> 4.11节


只有当一级二级页表的 PTE 都设置了用户写权限后,用户才能对对应的物理地址进行读写.
所以我们可以在一级页表首先给用户写权限,再在二级页表上面根据需要限制用户的权限,对
物理页进行保护.   由于一个物理页可能被映射到不同的虚拟地址上去(譬如一块内存在不同进程间共享),
当这个页需要在一个地址上解除映射时, os 不能直接把这个 page 回收,而是要先看看它还有没有映射
到别的虚拟地址.  这是通过查找管理该物理页的 Page 数据结构的成员变量 ref 来实现的, 如果ref = 0,
表示没有虚拟页到物理页的映射关系了, 就可以把这个物理页给回收了,从而这个物理页是 free 的了,可以
再被分配.  page_insert() 函数将物理页映射在了页表上.  可参看 page_insert() 函数的实现来
了解 os kernel 是如何维护这个变量的.  当不需要再访问这块虚拟地址时,可以把这块物理页回收并在
将来用在其他地方.  取消映射由 page_remove() 来做,这其实是 page_insert() 的逆操作.


建立好 一一映射的二级页表后,接下来就要使能分页机制了,这主要是通过 enable_page() 函数
实现的,这个函数主要做了两件事:

1 ==> lcr3 指令把页目录表的起始地址存入 CR3 寄存器中 physical address of boot-time page directory 

2 ==> lcr0 指令把 CR0 中的 CR0_PG  设置

执行完 enable_page 函数后, 计算机系统进入了分页模式! 但到这一步还没建立好完整的 段页式
映射.   OS 在最开始通过 kern_enty 函数设置了临时的新段映射机制. 这个临时的新段映射不是
最简单的对等映射, 导致虚拟地址 和 线性地址 不相等.  这里需要注意: 刚进入分页模式的时刻是
一个过渡过程中, 虚拟地址,线性地址 以及 物理地址 之间的映射关系为 :

    # linear addr 在  0  ~~ 4 MB 之外的 三者映射关系

   stage 3 ==> vir addr -  0xC000 0000 = linear addr = phy addr + 0xC000 0000

而我们希望的段页式映射的最终映射关系为:

   stage 4 ==>  virt addr = linear addr = phy addr + 0xC000 0000

这里最终的段映射是简单的段对等映射 (virt addr = linear addr). 我们需要进一步调整段映射关系
,即重新设置新的  GDT , 建立对等段映射. 这个特殊的阶段,如果不把段映射关系改为 virt addr = la
,则通过段页式两次地址转换后, 无法得到正确的物理地址.


为此我们需要进一步调用 gdt_init() 函数, 根据新的 gdt 全局段描述符表内容,恢复简单的段对等映射
关系,即使得 virt addr = linear addr. 这样在执行完 gdt_init() 后,通过的段机制和页机制实现
的地址映射关系为:

  stage 4 ==>   vir addr = linear addr = phy addr + 0xC000 0000
    
这里存在一个问题是,在调用 enable_page() 函数到执行 gdt_init() 函数之前,内核使用的还是旧的段
表映射, 即:

  stage 3 ==> vir addr -  0xC000 0000 = linear addr = phy addr + 0xC000 0000

如何保证此时内核依然能够正常工作呢？其实只需让 index=0 的页目录项 PDE 的内容等于以索引值
为 (KERN_BASE >>22) 的目录表项的内容即可.   目前内核大小不超过 4MB (实际上是 3MB,因为内核
从 0x10 0000 开始),这样就只需要让页表在 0 ~ 4MB 的线性地址与 KERN_BASE ~ KERN_BASE + 4MB
的线性地址获得相同的映射即可,都映射到 0 ~ 4MB 的物理地址空间, 具体实现为:

    boot_pgdir[0] = boot_pgdir[PDX(KERN_BASE)]; //PDX(KERN_BASE) = 768

实际上这种映射 限制了内核的大小. 当内核大小超过预期的 3MB 就可能导致打开分页之后内核 crash,
在后面的实验中,页的确出现了这种情况.解决方法同意简单,就是 copy 更多的高地址对应的页目录项 PDE
内容到低地址对应的页目录项 PDE 中即可.

当执行完成 gdt_init() 之后,新的段页式映射已经建立好了, 上面的 0 ~ 4MB 的线性地址与 
0 ~ 4MB 的物理地址 一一映射关系已经没有用了.   所以可以通过 下面语句解除这个 老的映射关系.

    boot_pgdir[0] = 0;

/****************************************************************************/

/************************************************************************/
/************************************************************************/

1、x86特权级------段选择子
(1)、在保护模式下,特权级总共有4个,编号从 0(最高特权)到3(最低特权).三类主
        要的资源,即内存、 I/O地址空间以及特权指令需要保护.特权指令如果被用户态的程序所
        使用,就会受到保护模式的保护机制限制,导致一个故障中断( general-protection exception).
        对内存和 I/O端口的访问存在类似的特权级限制.为了更好地理解不同特权级,这里先介绍
        三个概念:
        CPL:当前特权级(Current Privilege Level)保存在 CS段寄存器(选择子)的最低
        两位, CPL 就是当前活动代码段的特权级,并且它定义了当前所执行程序的特权级
        别)
   DPL:描述符特权(Descriptor Privilege Level) 存储在段描述符中的权限位,用于
        描述对应段所属的特权等级,也就是段本身真正的特权级.
   RPL:请求特权级RPL(Request Privilege Level) RPL保存在选择子的最低两位. RPL
        说明的是进程对段访问的请求权限,意思是当前进程想要的请求权限.RPL 的值由
        程序员自己来自由的设置,并不一定 RPL>=CPL,但是当RPL<CPL 时,实际起作用
        的就是 CPL 了,因为访问时的特权检查是判断:max(RPL,CPL)<=DPL 是否成立,所
        以 RPL 可以看成是每次访问时的附加限制,RPL=0 时附加限制最小, RPL=3 时附加
        限制最大.
        
(2)、当访问门(中断、调用等)时需要CPL <= DPL[门] & CPL >= DPL[段]
     当访问段(访存等)时需要MAX(RPL,CPL)  <= DPL[段]

(一)段机制
段的基地址、界限及保护属性,存储在段的描述符表中,在虚拟—线性地址转换过程中要对描述符进行访问.段描述符又存储在存储器的段描述符表中,该描述符表是段描述符的一个数组.

二)、页机制        
在分页内存管理中,一方面把实际物理内存(也称主存) 划分为许多个固定大小的内存块,称为物理页面,或者是页框( page frame);另一方面又把 CPU(包括程序员)看到的虚拟地址空间也划分为大小相同的块,称为虚拟页面,或者简称为页面、页( page).页面的大小要求是 2 的整数次幂,一般在 256 个字节到 4M 字节之间.在
本书中,页面的大小设定为 4KB. 在 32 位的 x86 中,虚拟地址空间是 4GB,物理地址空间也也是 4GB,因此理论上程序可访问到 1M 个虚拟页面和 1M 个物理页面.软件的每一物理页面都可以放置在主存中的任何地方,分页系统提供了程序中使用的虚地址和主存中的物理地址之间的动态映射.这样当程序访问一个虚拟地址时,支持分页机制的相关硬件自动把 CPU 访问的虚拟地址虚拟地址拆分为页号(可能有多级页号)和页内偏移量,再把页号映射为页帧号,最后加上页内偏移组成一个物理地址,这样最终完成对这个地址的读/写/执行等操作.
CR3寄存器 的内容是对应页目录表的物理基地址;页目录表可以指定1K 个页表,这些页表可以分散存放在任意的物理页中,而不需要连续存放;每张页表可以指定 1K 个任意物理地址空间的页.存储页目录表和页表的基地址是按 4KB 对齐.具体过程描述如下:
首先, CPU 把控制寄存器 CR3 的高 20 位作为页目录表所在物理页的物理基地址,再把需要进行地址转换的线性地址的最高 10 位(即 22~ 31 位)作为页目录表的索引, 查找到对应的页目录表项,这个表项中所包含的高 20 位是对应的页表所在物理页的物理基地址;然后,再把线性地址的中间 10 位(即 12~21 位)作为页表中的页表项索引, 查找到对应的页表项,这个表项所包含的的高 20 位作为线性地址的基地址(即页号)对应的物理地址的基地址(即页号);最后, 把页帧号作为 32 位物理地址的高 20 位,把线性地址的低 12 位不加改变地作为 32 位物理地址的低 12 位,形成最终的物理地址.
总而言之,在建立二级页表并建立正确虚实映射关系的过程中,需要完成的事务主要包括:

①给页目录表动态分配空间,给页表分配空间  
②让页基址寄存器的高20位内容为页目录表的高20位物理地址  
③在虚地址高10位的值为index的页目录项中的高20位填写页表的高20位物理地址,设置有效位  
④在虚地址中10位的值为index的页表项中中的高20位填写物理页地址的高20位物理地址,设置有效位
需要注意的是,在设置完映射关系之后,又取消了第二个映射关系原因是为实现对等映射,更新了GDT表项之后,第二个映射就没有意义了,所以需要unmap.





#### 系统执行中地址映射的四个阶段

段映射 : 在 proj1 中,简单的段映射(对等映射关系),保证了 physical addr === virtual addr; 也就是通过建立全局段描述符表 GDT,让每个段的 base addr = 0, 从而确定了对等映射关系.

段页式映射: 在 proj2 中, 在段地址映射 的基础上 进一步引入了 页地址映射,形成了组合式的段页式地址映射. 更灵活,更复杂.    为了建立正确的地址建立正确的地址映射关系, ld 静态链接器 生成了 kernel ELF 执行代码的 virtual addr, 而 bootloader 与 kernel ELF 协同工作, 通过在 runtime 时对地址映射一系统"变换", 从计算机加电, 启动段式管理机制----> 启动段页式管理机制. 在段页式管理机制下运行这整个过程中, virtual addr 到 physical addr 的映射产生了多次变化, 实现了最终的 段页式映射关系 :

                virtual addr = linear addr = physical addr + 0xC000 0000

/****************************************************************************/
  
这个过程是如何一步一步的实现的呢？

观察 link script  -> kernel.ld  文件在 proj1 与 proj2 的区别.

proj1 ===>  kernel ELF link addr = 0x10 0000,这个地址是 virtual addr. 由于段映射关系为对等映射 (virtual addr === physical addr),所以 kernel 的入口函数 kern_init 的物理地址为 0x10 0000.

总结:  virtual addr = linear addr = physical addr

/****************************************************************************/

proj2 ===>  kernel ELF link addr = 0xC010 0000,这个地址也是 virtual addr.  不同的是 kernel 的入口函数变为了 kern_enty .这里差异非常大.   proj1 和 proj2 bootloader 将 kernel ELF 都放在了起始 physical addr=0x10 0000 的物理内存空间. 这实际说明了 kernel ELF 在 proj1 和 proj2 采用了不同的地址映射.
   
     proj2 不同的阶段使用了不同的 virtual addr / linear addr /physical addr 之间的映射关系.

      stage 1 ==> bootloader stage, 从 bootloader 的 start 函数到执行 kernel ELF 的 
                  kern_enty 函数之前 (kernel ELF 还未加载),  这个阶段的 
                  virtual addr / linear addr /physical addr 之间的映射关系与 proj1 相同.
                  

                  virtual addr = linear addr = physical addr

/****************************************************************************/

      stage 2 ==> 从 kern_enty 函数开始,到执行 enable_page(mm/pmm.c) 函数之前再次更新了
                  段映射, 还没有启动页映射机制.  
                  
                  bootmain.c 中的 boot_main() 被调用时还处于第一阶段.由于 gcc 编译出的虚拟起始地址从 0xC010 0000 开始 (kernel.ld), kernel ELF 被 bootloader 放置在从 physical addr=0x10 0000 处开始的物理内存中 (Higher Half Kernel).   
                  
                  由于此时系统还只是采用段式映射,如果我们还是使用 stage 1 的映射关系的话,我们根本不能访问到正确的内存空间,比如要访问虚拟地址 0xC0100000, 其物理地址应该在 0x00100000,而在这种映射下, 我们却访问了 0xC0100000 的物理地址. 因此, 为了让 虚拟地址 和 物理地址能匹配,我们必须要重新设计 GDT.

                #define REALLOC(x) (x - KERN_BASE)

                __GDT:
                    SEG_NULLASM 
                    SEG_ASM(STA_X | STA_R, - KERN_BASE, 0xffffFFFF)  # code segment
                    SEG_ASM(STA_W, - KERN_BASE, 0xFFFFffff)  # data segment
                __GDT_DESC:
                    .word 0x17    # sizeof(__GDT) - 1
                    .long REALLOC(__GDT)

                可以看到,此时段的起始地址由0变成了-KERNBASE.因此
                这个阶段的 virtual addr / linear addr /physical addr 之间的映射关系

                virtual addr -  0xC000 0000 = linear addr = physical addr 
                
                这里需要注意两个地方:
                第一,lgdt载入的是线性地址,所以用 .long REALLOC(__gdt)
                将 GDT 的虚拟地址转换成了线性地址;
                
                第二,因为在载入 GDT 前,映射关系还是 stage 1 的映射关系;

                所以当 kern_enty 函数完成新的段映射关系后, 且 kernel 在没有建
                立好 页映射机制之前, CPU 按照 kernel 中的 virtual addr 执行, 能够被分段机
                制映射到正确的 physical addr 上,确保 kernel 运行正确. 
/****************************************************************************/

                此时 CPU 在寻址时还是只采用了 分段机制. 最后使能 分页映射机制 (mm/pmm.c) 
                enable_page 函数. 一旦执行完毕 enable_page 函数中的加载 cr0 指令(指令让 
                CPU 使能分页机制), 则接下来的内存访问是基于 段页式的映射关系了.
/****************************************************************************/

    stage 3 ==> 从 enable_page 函数开始,到执行 gdt_init 函数之前,启动了 页映射机制, 但没有
                第三次更新段映射.这时的 virtual addr / linear addr /physical addr 之间
                的映射关系很微妙:


                并且在 boot_map_segment() 中将 线性地址 la 按照如下规则进行映射:
                
                linear addr - 0xC0000000 = phy addr

                这就导致此时虚拟地址,线性地址和物理地址之间的关系如下:

                virtual addr -  0xC000 0000 = linear addr = physical addr + 0xC000 0000

                这肯定是错误的,因为我们根本不能通过 虚拟地址 获取正确的 物理地址, 我们可以继续用之前例子.  我们还是要访问 vir addr 0xC0100000, 则其 la 就是 0x00100000 ,然后通过页映射后的 phy addr 是 A = (0x00100000 - 0xC000 0000) 我们本来是要访问 0x00100000,却访问了 A, 因此我们需要想办法来解决这个问题,即要让映射还是:
                
                virt addr - 0xC0000000 = linear addr = phy addr

                这个和 stage 1 到 stage 2 的转变类似,都是需要调整映射关系.为了解决这个问题,使用了
                一个小技巧:在boot_map_segment()中, 线性地址 0xC000 0000-0xC040 0000(4MB)对应的物理地址是 0x0~0x0040 0000(4MB).如果我们还想使用虚拟地址 0xC000 0000 来映射物理地址 0x0, 也就是线性地址 0x0 来映射物理地址 0x0,我们可以这么做:

                在开启页映射机制前, 将页目录表 PDT 中的第 0 项和 第 PDX(KERNBASE) = 768 项设置为
                相同的映射(boot_pgdir[0] = boot_pgdir[PDX(KERNBASE)]),这样,当虚拟地址是
                0xC000 0000时, 其对应的线性地址就是 0x0, 然后通过页表 PT 可以知道其物理地址也是0x0.

                举个例子,比如 enable_paging()后应该运行 gdt_init(),gdt_init()的虚拟地址是
                0xC010 38CC,那么其对应的线性地址就是 0x0010 38CC,它将映射到页目录表 PDT 的第 1
                项 PDE.    并且这个线性地址 和 0xC010 38CC 最终是指向同一个物理页,它们对应的物理地址是 0x0010 38CC.而根据 gdt_init()的虚拟地址和链接地址可知,gdt_init()的物理地址就是 0x0010 33CC,因此通过这种地址变换后,我们可以正确的取到之后的指令.
                
                最终 stage 3 分两个部分 映射关系

                为什么是 4MB ？
                因为我们把 boot_pgdir[0] 也就是 PDT 的 第一个 PDE (1024 个 PT)给重新设置了.1024 个 PT 能描述 1024 * 4B = 4MB 内存.

                # linear addr 在  0  ~~ 4 MB 之外的 三者映射关系
                virtual addr -  0xC000 0000 = linear addr = physical addr + 0xC000 0000

                # linear addr 在  0  ~~ 4 MB 之内的 三者映射关系
                virtual addr -  0xC000 0000 = linear addr = physical addr 


    //temporary map:
    //virtual_addr 3G~3G+4M = linear_addr 0~4M = linear_addr 3G~3G+4M = phy_addr 0~4M
    boot_pgdir[0] = boot_pgdir[PDX(KERN_BASE)];

    用来建立物理地址 在 0 ~ 4MB 之内的临时映射关系
                  virtual addr -  0xC000 0000 = linear addr = physical addr 

  /****************************************************************************/
    
      stage 4 ==> 从 gdt_init 函数开始,第三次更新了段映射(重新设置 GDT),形成了新的段页式映射机
                  制,并且取消了 stage 3 生成的临时 页映射关系. 新的GDT又将段的起始地址变为了0.
                    
                  执行下列代码, 把 boot_pgdir[0] 的第一个页目录表项(PTE 0~4MB) 清零来取消临
                  时的 页映射关系   
                   //disable the map of virtual_addr 0~4M
                   boot_pgdir[0] = 0;

                  这时就是最终期望的 virtual addr / linear addr /physical addr 之间的映射
                  关系
                
                  virtual addr = linear addr = physical addr + 0xC000 0000


/****************************************************************************/

## 自映射

在这个 proj2 中,为了方便快速地访问页目录项 PDE 和 页表项 PTE,用了一个小技巧 --> 也就是自映射.

如果用常规方法的话,要访问一个页表项 PTE,必须

1 ==>  先使用 虚拟地址 访问到对应的 PDX(la) 页目录项 PDE;
2 ==>  然后通过其中的页表地址(物理地址), 再转回成对应的 页表 虚拟地址;
3 ==>  然后访问 页表的虚拟地址, 搜索整个 PTX(la) 页表的每个 PTE 

这个过程是比较繁琐的,为了方便的访问这些表项,我们使用了自映射.

我们下面通过代码来看看什么是自映射以及如何使用自映射来快速查找表项的内容.

/****************************************************************************/

### 自映射的实现

首先,我们将页 Page 一个目录项 PDE 的值设置为 页目录表 PDT 的物理地址,这么做的作用就是当我们使用的虚拟地址,高 10 位为 (1111 1010 11) 时,它对应的页表 PT 就是页目录表 PDT,这也就实现了自映射:

/* VPT = 0xFAC0 0000 = 1111 1010 11 | 00 0000 0000 | 0000 0000 0000 
注意,这个地址是在 kernel 有效地址之外的地址(有效地址从 0xC000 0000 ~ 0xF800 0000) */
boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;
当执行上述语句时,就确保了 VPD 变量的值 就是 PDT 的起始虚拟地址, 并且 vpt 是 PDT 中的第一个 PDE
指向的 PT 的起始虚拟地址.

这样之后,我们来看看如何使用这种自映射.我们还定义了一个地址 VPD:


VPD = 0xFAFE B000 = 1111 1010 11 | 11 1110 1011 | 0000 0000 0000 


/****************************************************************************/

通过 VPD 和 VPT,我们就能方便的访问页目录项 PDE 和页表项 PTE 了.下面给一个例子说明如何获取0xF800 0000 所在的 页目录项 PDE 和 页表项 PTE:

首先,我们思考下直接通过 VPD = (1111 1010 11 | 11 1110 1011 | 0000 0000 0000 ) 这个地址我们
能访问到什么？

在页目录表 PDT 中通过 高 10 bit (1111 1010 11) 可以找到 boot_pgdir[PDX(VPT)] 这项 PDE,这项又直接指回了 boot_pgdir, 此时我们将页目录表 PDT 当成了页表 PT .

我们此时再用 中间 10 bit (11 1110 1011),还是找到 boot_pgdir[PDX(VPT)] 这项 PTE ,它还是指回boot_pgdir.

也就是说,VPD 这个地址最终就是指回了页目录表 PDT ,并且我们可以通过它的 低 12 bit 来访问页目录表 PDT .

0xF800 0000 地址对应的 页目录项 PDE 是 (1111 1000 00) ,我们只要将这个值放在 VPD 的 低 12bit 就行了.

也就是说我们通过 VPD + 0xF800 0000 >> 22 就可以获得 0xF800 0000 对应的 页目录项 PDE.

如果懂了如何获取页目录项 PDE ,再来看如何获取页表项 PTE 就很简单了.

首先,我们根据 VPT 可以访问到 页目录表 PDT ,这个页目录表 PDT 同样也是 VPT 对应的页表 PT,通过VPT 的 低 22 bit 我们就可以像访问 页表 PT 一样的访问 页目录表 PDT.

/****************************************************************************/
??????????????
0xF800 0000 的高 20 bit 是 (1111 1000 00|00 0000 0000),用这个地址我们就可以通过 页目录表 
PDT 找到它对应的 页表项 PTE 了.这里我觉得指导书上说的不对,如果要能访问一个非 4MB 对齐的地址,
不能直接使用 VPT + addr >> 12  而要用 VPT + [addr_31_22 : 00 : addr_21_12];  

比如一个高 20 bit 地址是 (1111 1000 11|00 0000 0011),那么要用在 VPT 中,(1111 1000 11)要放在 VPT 的 21_12 bit ,用于找到 页目录表项 PDE ,从而找到页表 PT,剩下的 (00 0000 0011)就要用来在页表 PT 中找页表项 PTE .      因为 VPT 中的 低 22 bit 为 0,如果直接使用 addr >> 22 的话,那么 (1111 1000 11|00 0000 0011) 就变成了 (0011 1110 00| 1100 0000 0011),这样的话,用于查找页目录项 PDE 和 页表项 PTE 的索引就不对了,所以我觉得应该是我说的那种转换方法.也即是 (1111 1000 11|00 0000 0011) 变成了 (1111 1000 11|0000 0000 0011),这样才和之前的是对应的. 如果要访问的地址是 4MB 对齐的,那么就可以直接用 VPT + addr >> 12了.

/****************************************************************************/



pte_t * const vpt = (pte_t *)VPT;
// vpd 的值就是 PDT 的起始 virtual addr 0xFAFEB000 (高10bit = 中10bit = 1003),确保vpt 是PDT 中
// 第一个 PDE 指向的 PT 的起始 virtual addr. 此时描述 kernel 虚拟空间的 PDT 的virtual addr 
//  = 0xFAFEB000, 大小=4kb. PT 的理论连续 virtual addr 空间为 0xFAC00000 ~ 0xFB000000,大小为 4MB  (一个 PDE 存储了 1024 个 PT , 虚拟地址 0xFAFEB000 存储着 PDT , 第一个 PDE 的第一个 PT 在虚拟地址为 0xFAC00000 处 ; 第二个 PT 在虚拟地址 0xFAC00000 + 4B 处; 最后一个 PT 在虚拟地址 0xFB000000处 ) 一个 PT 4K , 1024 个 PT = 1024 * 4K = 4MB.

//理论上可以有 1024 个 PDT, 1024 * 1024 = 1M 个 PTE, 即可映射 1024*4MB=4GB 的地址空间 (实际上不会用完这么多页).
pde_t * const vpd = (pde_t *)PG_ADDR(PDX(VPT), PDX(VPT), 0);


在 memlayout.h 中定义了  
#define KERN_BASE            0xC0000000  //
#define KMEMSIZE       		 0x38000000  // 0x380 = 896 MB the maximum amount of physical memory  
#define KERN_TOP             (KERN_BASE + KMEMSIZE) 

os kernel 只支持 896MB 的物理内存空间, 这个 896MB 只是一个设定,可以根据情况改变. 
则最大的 kernel virtual addr = 0xF8000000


所以最大内核虚地址 KERN_TOP 的 PDE 的虚拟地址为

vpd + 0xF800 0000/ 0x40 0000 * 4 = 0xFAFE B000 + 0x3E0 * 4 = 0xFAFE BF80

所以最大内核虚地址 KERN_TOP 的 PTE 的虚拟地址为

vpt + 0xF800 0000/ 0x40 0000 * 4 = 0xFAC0 0000 + 0xF8000 * 4 = 0xFAFE 0000

/****************************************************************************/

分页机制是 80X86 内存管理机制的第二部分.它在分段机制的基础上完成了虚拟(逻辑)地址到物理地址转换的过程.分段机制把逻辑地址转换成线性地址,而分页机制则把线性地址转换成物理地址. 分页机制可以用于任何一种分段机制. 处理器分页机制会把线性地址空间(段已经映射到其中)划分成页面,然后这些线性地址空间页面被映射到物理地址空间的页帧( 也叫页框)上. 分页机制几种页面级保护措施,可和分段机制保护机制合用或替代分段机制的保护措施. 例如:在基于页面的基础上加强读/写保护.另外,在页面单元上,分页机制还提供了用户- 超级用户 两级保护.


### (个人理解) 不同叫法的地址(Address)理解:

1:--->虚拟地址(Virtual Address)是指由程序产生的由段选择符和段内偏移地址两个部分组成的地址.因为这两部分
      组成的地址并没有直接用来访问物理内存,而是需要通过分段地址变换机制处理或映射后才对应到物理内存地址上,因此这种地址被称为虚拟地址.虚拟地址空间由 GDT 映射的全局地址空间和由 LDT 映射的局部地址空间组成.选择符的索引部分由13 bit 表示,加上区分 GDT 和 LDT的 1 bit ,因此 Intel 80X86 CPU 可以提供索引 16384 (2 ^ 14)个选择符.若每个段的长度都取最大值4GB,则最大虚拟地址空间范围是  2^14 * 4GB = 64TB.

2:--->逻辑地址(Logical Address) 是指由程序产生的与段相关的偏移地址部分.在Intel 保护模式下即是指程      
      序执行代码段限长内的偏移地址(假定代码段,数据段完全一样).应用程序员仅仅需要与逻辑地址打交道,而分
       段和分页机制对他来说是完全透明的,仅仅由系统编程人员涉及.不过有些资料并不区分逻辑地址和虚拟地址的概念,而是将他们统称为逻辑地址.

3:---> 线性地址(Linear Address) 是虚拟地址到物理地址变换的中间层,是处理器可以寻址的内存空间(称为线性
       地址空间)中的地址.程序代码会产生逻辑地址,或者说是段中的偏移地址,加上相应段的基地址就生成了一个线性地址.如果启用了分页机制,那么线性地址可以再经过变换以产生一个物理地址.若没有启动分页机制(PG =1 开启分页), 那么线性地址直接就是物理地址.Intel 80386的线性地址空间范围是4GB.

4:---> 物理地址(Physical Address) 是指出现在CPU 外部地址总线上的寻址物理内存的地址信号,是地址变换的
      最终结果地址.如果启动了分页机制,那么线性地址会使用页目录和页表中的项变换成物理地址.如果没有启动分页机制,那么线性地址就直接成为了物理地址了.

5:---> 虚拟存储(或 虚拟内存)(Virtual Memory)是指计算机呈现出要比实际拥有的内存大得多的内存量.因此它
      允许程序员编制并允许比实际系统拥有的内存大很多的程序.这使得许多大型项目也能够在具有有限内存资源的系统上实现.一个很恰当的比喻是: 你不需要很长的轨道就可以让一列火车从上海开到北京.你只需要足够长的铁轨(比如说3 公里)就可以完成这个任务.采取的方法是把后面的铁轨立刻铺到火车的前面,只要你的操作足够快并能满足要求,列车就能像在一条完整的轨道上运行.这也就是虚拟内存管理需要完成的任务.在Linux kernel 中,给每个程序(进程)都划分了总容量为64MB 的虚拟内存空间.因此程序的逻辑地址范围是0x000 0000 到 0x400 0000.

6:---> 如上所述,有时我们也把逻辑地址称为虚拟地址.因为逻辑地址与虚拟内存空间的概念类似,并且也是与实际物理内存容量无关.



